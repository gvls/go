## 2 `进制` 

### 3  `二进制` 
0 ~ 1
in go, it **can't** write direct
... 2^12 2^11 2^10 256   128 64 32 16 8 4 2 1
`有符号数的二进制最高位是符号位` : 0 is `正` and 1 is `负` 
`正数和0的源码,反码,补码都一样` 
`计算机运算都以 补码 的方式运算` : `运算前转换为补码，运算后转换补码为源码` 

* `负数源码` 

* `负数反码` : `符号位不变，其他位取反` 

* `负数补码` : `负数反码` + 1


### 3  `十进制` 
0 ~ 9
in go, it can write direct

### 3  `八进制` 
0 ~ 7
begin is `0` 
in go, it can write direct

### 3  `十六进制` 
0 ~ 9 + A ~ F | a ~ f
begin is `0x` or `0X` 
in go, it can write direct



### 3  transform
all transition pass `十进制` 

#### 4   else  =>  `十进制` 
`乘`
sum ( (every bit)`<被转的进制数>`^(bit-1) )

#### 4   `十进制`  =>  else
`除`
number / `<要转成的进制数>` until `商` == 0   and `从底到顶写出每步的余数` 

#### 4   else  =>  `二进制` 
`组合` 
begin from right, per `<转8为3个，转16为4个>` as one part to transform `十进制` and transform `十进制` to `要转的进制` 

#### 4   `二进制`  =>  else
`分解` 
begin from right, per bit transform `十进制` and transform `十进制` to `二进制(8转为3bit，16转为4bit)` 
