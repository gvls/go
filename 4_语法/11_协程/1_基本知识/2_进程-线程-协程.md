##  进程 
程序在操作系统中的一次执行过程 
系统资源分配的基本单位 
一个**系统**可以有 1 ~ more 进程
每个进程都有独立的代码和数据空间（进程上下文）


##  线程 
进程的一个执行实例，程序调度与执行的最小单位 
系统调度的基本单位 
多线程: 一个**进程**可以有 1 ~ more 线程 
线程有独立的运行栈和程序计数器，自己不拥有系统资源，只拥有一点儿在运行中必不可少的资源，但它可与同属一个进程的其它线程共享进程所拥有的全部资源。
线程拥有自己独立的栈和共享的堆，共享堆，不共享栈，线程的切换一般也由操作系统调度。
相当于轻量级进程， 开销比进程少
一个标准的线程由线程ID，当前指令指针(PC），寄存器集合和堆栈组成
线程的切换，由系统决定
因为线程切换耗费资源,大量的线程可能会影响性能


##  协程
相当于轻量级线程，开销比线程少
多协程: 一个**线程**可以有 1 ~ more 协程 
在堆中创建栈来模拟线程
由主线程创建，当主线程退出，所有协程都会退出
很容易创建 百万 协程
用户空间创建，运行在线程上，由用户控制协程的切换
和线程类似，共享堆，不共享栈，协程的切换一般由程序员在代码中显式控制。它避免了上下文切换的额外耗费，兼顾了多线程的优点，简化了高并发程序的复杂。
Goroutine和其他语言的协程（coroutine）在使用方式上类似，但从字面意义上来看不同（一个是Goroutine，一个是coroutine），再就是协程是一种协作任务控制机制，在最简单的意义上，协程不是并发的，而Goroutine支持并发的。因此Goroutine可以理解为一种Go语言的协程。
开销小 : POSIX的thread API虽然能够提供丰富的API，例如配置自己的CPU亲和性，申请资源等等，线程在得到了很多与进程相同的控制权的同时，开销也非常的大，在Goroutine中则不需这些额外的开销，所以一个Golang的程序中可以支持10w级别的Goroutine。
每个 goroutine (协程) 默认占用内存远比 Java 、C 的线程少（goroutine：2KB ，线程：8MB）
调度性能好 : 在Golang的程序中，操作系统级别的线程调度，通常不会做出合适的调度决策。例如在GC时，内存必须要达到一个一致的状态。在Goroutine机制里，Golang可以控制Goroutine的调度，从而在一个合适的时间进行GC。
在应用层模拟的线程，它避免了上下文切换的额外耗费，兼顾了多线程的优点。简化了高并发程序的复杂度。
缺点： 协程调度机制无法实现公平调度。
